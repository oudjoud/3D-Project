# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1f76o31JnYV4X8-ciSicp2WSR4Br2GRsN
"""

import re
import numpy as np

# Read the content of the file
with open('Mesure_Salle_30_01_2024_NÂ°3', 'r') as file:
    content = file.read()

# Use regular expressions to extract the distance data
pattern = re.compile(r'\b(\d+|X)\s*:\s*\d+\b')
matches = pattern.findall(content)

# Convert 'X' to the previous distance value
distances = []
previous_value = None

for match in matches:
    if match == 'X':
        if previous_value is not None:
            distances.append(previous_value)
    else:
        distances.append(int(match))
        previous_value = int(match)

# Create 8x8 matrices
matrices = [distances[i:i+8] for i in range(0, len(distances), 8)]

# New list to store matrices that meet the condition
selected_matrices = []

# Print each set of 8 lines separately, skipping every second line
for i in range(0, len(matrices), 16):
    for j in range(16):
        if (i + j) % 2 == 0:
            selected_matrices.append(matrices[i + j])
            # print(matrices[i + j])

print(selected_matrices)

grouped_matrices = []

# Iterate over matrices and group each 8 arrays into a new matrix
for i in range(0, len(selected_matrices), 8):
    current_group = selected_matrices[i:i+8]
    grouped_matrix = np.vstack(current_group)
    grouped_matrices.append(grouped_matrix)

# Now 'grouped_matrices' contains the matrices grouped in sets of 8
for matrix in grouped_matrices:
    print(matrix)
    print()

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
# Given list of matrices

# Calculate the average matrix
average_matrix = np.mean(grouped_matrices, axis=0)

# Print the result
print(average_matrix)

# Get the coordinates and distances
x, y = np.meshgrid(np.arange(average_matrix.shape[1]), np.arange(average_matrix.shape[0]))
z = average_matrix


# Offset the coordinates to place the sensor at (0, 0, 0)
x_offset, y_offset = x - x.max() / 2, y - y.max() / 2

# Create a 3D scatter plot
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.scatter(x.ravel(), y.ravel(), z.ravel(), c='b', marker='o')

# Plot sensor at (0, 0, 0)
ax.scatter(0, 0, 0, c='r', marker='s', label='Sensor')

# Set labels
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Distance to Sensor')
ax.set_title('3D Scatter Plot of Object Distances to Sensor')
# Adjust viewing angles
ax.view_init(elev=00, azim=90)  # Adjust the elevation and azimuth angles

# Add legend
ax.legend()

plt.show()

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

first_matrix = grouped_matrices[0]

# Convert the list to a NumPy array
first_matrix = np.array(first_matrix)

# Get the coordinates and distances
x, y = np.meshgrid(np.arange(first_matrix.shape[1]), np.arange(first_matrix.shape[0]))
z = first_matrix

# Offset the coordinates to place the sensor at (0, 0, 0)
x_offset, y_offset = x - x.max() / 2, y - y.max() / 2

# Create a 3D scatter plot
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.scatter(x.ravel(), y.ravel(), z.ravel(), c='b', marker='o')

# Plot sensor at (0, 0, 0)
ax.scatter(0, 0, 0, c='r', marker='s', label='Sensor')

# Set labels
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Distance to Sensor')
ax.set_title('3D Scatter Plot of Object Distances to Sensor')
# Adjust viewing angles
ax.view_init(elev=00, azim=90)  # Adjust the elevation and azimuth angles

# Add legend
ax.legend()

# Get the coordinates and distances for each matrix
x1, y1 = np.meshgrid(np.arange(average_matrix.shape[1]), np.arange(average_matrix.shape[0]))
z1 = average_matrix

x2, y2 = np.meshgrid(np.arange(first_matrix.shape[1]), np.arange(first_matrix.shape[0]))
z2 = first_matrix

# Offset the coordinates to place the sensor at (0, 0, 0)
x_offset1, y_offset1 = x1 - x1.max() / 2, y1 - y1.max() / 2
x_offset2, y_offset2 = x2 - x2.max() / 2, y2 - y2.max() / 2

# Create a 3D scatter plot with adjusted coordinates
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

# Plot objects from matrix1 in blue
ax.scatter(x_offset1.ravel(), y_offset1.ravel(), z1.ravel(), c='r', marker='s', label='Average Matrix')

# Plot objects from matrix2 in red
ax.scatter(x_offset2.ravel(), y_offset2.ravel(), z2.ravel(), c='b', marker='o', label='First Matrix')

# Plot sensor at (0, 0, 0)
ax.scatter(0, 0, 0, c='g', marker='^', label='Sensor')

# Set labels
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Distance to Sensor')
ax.set_title('3D Scatter Plot of Object Distances to Sensor')

# Adjust viewing angles
ax.view_init(elev=00, azim=90)  # Adjust the elevation and azimuth angles

# Add legend
ax.legend()

plt.show()

errors_matrices = [(matrix - average_matrix)/average_matrix for matrix in grouped_matrices]

# Print the errors matrices
for i, error_matrix in enumerate(errors_matrices):
    print(f"Error Matrix {i + 1}:")
    print(error_matrix)
    print()

# Calculate the average error matrix
average_error_matrix = np.mean(errors_matrices, axis=0)


print("Average Error Matrix:")
print(average_error_matrix)

